// Code generated by MockGen. DO NOT EDIT.
// Source: pkg/helm/factory.go

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	reflect "reflect"

	helm "github.com/aws/eks-anywhere/pkg/helm"
	gomock "github.com/golang/mock/gomock"
)

// MockExecuteableClient is a mock of ExecuteableClient interface.
type MockExecuteableClient struct {
	ctrl     *gomock.Controller
	recorder *MockExecuteableClientMockRecorder
}

// MockExecuteableClientMockRecorder is the mock recorder for MockExecuteableClient.
type MockExecuteableClientMockRecorder struct {
	mock *MockExecuteableClient
}

// NewMockExecuteableClient creates a new mock instance.
func NewMockExecuteableClient(ctrl *gomock.Controller) *MockExecuteableClient {
	mock := &MockExecuteableClient{ctrl: ctrl}
	mock.recorder = &MockExecuteableClientMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockExecuteableClient) EXPECT() *MockExecuteableClientMockRecorder {
	return m.recorder
}

// Delete mocks base method.
func (m *MockExecuteableClient) Delete(ctx context.Context, kubeconfigFilePath, installName, namespace string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Delete", ctx, kubeconfigFilePath, installName, namespace)
	ret0, _ := ret[0].(error)
	return ret0
}

// Delete indicates an expected call of Delete.
func (mr *MockExecuteableClientMockRecorder) Delete(ctx, kubeconfigFilePath, installName, namespace interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockExecuteableClient)(nil).Delete), ctx, kubeconfigFilePath, installName, namespace)
}

// InstallChart mocks base method.
func (m *MockExecuteableClient) InstallChart(ctx context.Context, chart, ociURI, version, kubeconfigFilePath, namespace, valueFilePath string, skipCRDs bool, values []string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "InstallChart", ctx, chart, ociURI, version, kubeconfigFilePath, namespace, valueFilePath, skipCRDs, values)
	ret0, _ := ret[0].(error)
	return ret0
}

// InstallChart indicates an expected call of InstallChart.
func (mr *MockExecuteableClientMockRecorder) InstallChart(ctx, chart, ociURI, version, kubeconfigFilePath, namespace, valueFilePath, skipCRDs, values interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InstallChart", reflect.TypeOf((*MockExecuteableClient)(nil).InstallChart), ctx, chart, ociURI, version, kubeconfigFilePath, namespace, valueFilePath, skipCRDs, values)
}

// InstallChartWithValuesFile mocks base method.
func (m *MockExecuteableClient) InstallChartWithValuesFile(ctx context.Context, chart, ociURI, version, kubeconfigFilePath, valuesFilePath string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "InstallChartWithValuesFile", ctx, chart, ociURI, version, kubeconfigFilePath, valuesFilePath)
	ret0, _ := ret[0].(error)
	return ret0
}

// InstallChartWithValuesFile indicates an expected call of InstallChartWithValuesFile.
func (mr *MockExecuteableClientMockRecorder) InstallChartWithValuesFile(ctx, chart, ociURI, version, kubeconfigFilePath, valuesFilePath interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InstallChartWithValuesFile", reflect.TypeOf((*MockExecuteableClient)(nil).InstallChartWithValuesFile), ctx, chart, ociURI, version, kubeconfigFilePath, valuesFilePath)
}

// ListCharts mocks base method.
func (m *MockExecuteableClient) ListCharts(ctx context.Context, kubeconfigFilePath string) ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListCharts", ctx, kubeconfigFilePath)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListCharts indicates an expected call of ListCharts.
func (mr *MockExecuteableClientMockRecorder) ListCharts(ctx, kubeconfigFilePath interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListCharts", reflect.TypeOf((*MockExecuteableClient)(nil).ListCharts), ctx, kubeconfigFilePath)
}

// PullChart mocks base method.
func (m *MockExecuteableClient) PullChart(ctx context.Context, ociURI, version string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PullChart", ctx, ociURI, version)
	ret0, _ := ret[0].(error)
	return ret0
}

// PullChart indicates an expected call of PullChart.
func (mr *MockExecuteableClientMockRecorder) PullChart(ctx, ociURI, version interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PullChart", reflect.TypeOf((*MockExecuteableClient)(nil).PullChart), ctx, ociURI, version)
}

// PushChart mocks base method.
func (m *MockExecuteableClient) PushChart(ctx context.Context, chart, registry string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PushChart", ctx, chart, registry)
	ret0, _ := ret[0].(error)
	return ret0
}

// PushChart indicates an expected call of PushChart.
func (mr *MockExecuteableClientMockRecorder) PushChart(ctx, chart, registry interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PushChart", reflect.TypeOf((*MockExecuteableClient)(nil).PushChart), ctx, chart, registry)
}

// RegistryLogin mocks base method.
func (m *MockExecuteableClient) RegistryLogin(ctx context.Context, registry, username, password string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RegistryLogin", ctx, registry, username, password)
	ret0, _ := ret[0].(error)
	return ret0
}

// RegistryLogin indicates an expected call of RegistryLogin.
func (mr *MockExecuteableClientMockRecorder) RegistryLogin(ctx, registry, username, password interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RegistryLogin", reflect.TypeOf((*MockExecuteableClient)(nil).RegistryLogin), ctx, registry, username, password)
}

// SaveChart mocks base method.
func (m *MockExecuteableClient) SaveChart(ctx context.Context, ociURI, version, folder string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SaveChart", ctx, ociURI, version, folder)
	ret0, _ := ret[0].(error)
	return ret0
}

// SaveChart indicates an expected call of SaveChart.
func (mr *MockExecuteableClientMockRecorder) SaveChart(ctx, ociURI, version, folder interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SaveChart", reflect.TypeOf((*MockExecuteableClient)(nil).SaveChart), ctx, ociURI, version, folder)
}

// Template mocks base method.
func (m *MockExecuteableClient) Template(ctx context.Context, ociURI, version, namespace string, values interface{}, kubeVersion string) ([]byte, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Template", ctx, ociURI, version, namespace, values, kubeVersion)
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Template indicates an expected call of Template.
func (mr *MockExecuteableClientMockRecorder) Template(ctx, ociURI, version, namespace, values, kubeVersion interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Template", reflect.TypeOf((*MockExecuteableClient)(nil).Template), ctx, ociURI, version, namespace, values, kubeVersion)
}

// UpgradeChartWithValuesFile mocks base method.
func (m *MockExecuteableClient) UpgradeChartWithValuesFile(ctx context.Context, chart, ociURI, version, kubeconfigFilePath, valuesFilePath string, opts ...helm.Opt) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, chart, ociURI, version, kubeconfigFilePath, valuesFilePath}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "UpgradeChartWithValuesFile", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpgradeChartWithValuesFile indicates an expected call of UpgradeChartWithValuesFile.
func (mr *MockExecuteableClientMockRecorder) UpgradeChartWithValuesFile(ctx, chart, ociURI, version, kubeconfigFilePath, valuesFilePath interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, chart, ociURI, version, kubeconfigFilePath, valuesFilePath}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpgradeChartWithValuesFile", reflect.TypeOf((*MockExecuteableClient)(nil).UpgradeChartWithValuesFile), varargs...)
}

// MockRegistryClient is a mock of RegistryClient interface.
type MockRegistryClient struct {
	ctrl     *gomock.Controller
	recorder *MockRegistryClientMockRecorder
}

// MockRegistryClientMockRecorder is the mock recorder for MockRegistryClient.
type MockRegistryClientMockRecorder struct {
	mock *MockRegistryClient
}

// NewMockRegistryClient creates a new mock instance.
func NewMockRegistryClient(ctrl *gomock.Controller) *MockRegistryClient {
	mock := &MockRegistryClient{ctrl: ctrl}
	mock.recorder = &MockRegistryClientMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRegistryClient) EXPECT() *MockRegistryClientMockRecorder {
	return m.recorder
}

// RegistryLogin mocks base method.
func (m *MockRegistryClient) RegistryLogin(ctx context.Context, registry, username, password string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RegistryLogin", ctx, registry, username, password)
	ret0, _ := ret[0].(error)
	return ret0
}

// RegistryLogin indicates an expected call of RegistryLogin.
func (mr *MockRegistryClientMockRecorder) RegistryLogin(ctx, registry, username, password interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RegistryLogin", reflect.TypeOf((*MockRegistryClient)(nil).RegistryLogin), ctx, registry, username, password)
}

// Template mocks base method.
func (m *MockRegistryClient) Template(ctx context.Context, ociURI, version, namespace string, values interface{}, kubeVersion string) ([]byte, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Template", ctx, ociURI, version, namespace, values, kubeVersion)
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Template indicates an expected call of Template.
func (mr *MockRegistryClientMockRecorder) Template(ctx, ociURI, version, namespace, values, kubeVersion interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Template", reflect.TypeOf((*MockRegistryClient)(nil).Template), ctx, ociURI, version, namespace, values, kubeVersion)
}

// MockExecutableBuilder is a mock of ExecutableBuilder interface.
type MockExecutableBuilder struct {
	ctrl     *gomock.Controller
	recorder *MockExecutableBuilderMockRecorder
}

// MockExecutableBuilderMockRecorder is the mock recorder for MockExecutableBuilder.
type MockExecutableBuilderMockRecorder struct {
	mock *MockExecutableBuilder
}

// NewMockExecutableBuilder creates a new mock instance.
func NewMockExecutableBuilder(ctrl *gomock.Controller) *MockExecutableBuilder {
	mock := &MockExecutableBuilder{ctrl: ctrl}
	mock.recorder = &MockExecutableBuilderMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockExecutableBuilder) EXPECT() *MockExecutableBuilderMockRecorder {
	return m.recorder
}

// BuildHelmExecutable mocks base method.
func (m *MockExecutableBuilder) BuildHelmExecutable(arg0 ...helm.Opt) helm.ExecuteableClient {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range arg0 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "BuildHelmExecutable", varargs...)
	ret0, _ := ret[0].(helm.ExecuteableClient)
	return ret0
}

// BuildHelmExecutable indicates an expected call of BuildHelmExecutable.
func (mr *MockExecutableBuilderMockRecorder) BuildHelmExecutable(arg0 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BuildHelmExecutable", reflect.TypeOf((*MockExecutableBuilder)(nil).BuildHelmExecutable), arg0...)
}
