package addonclients

import (
	"context"
	"fmt"
	"path"

	"github.com/aws/eks-anywhere/pkg/cluster"
	"github.com/aws/eks-anywhere/pkg/logger"
	"github.com/aws/eks-anywhere/pkg/templater"
	"github.com/aws/eks-anywhere/pkg/types"
)

const upgradeFluxconfigCommitMessage = "Upgrade commit of flux configuration; generated by EKS-A CLI"

func (f *FluxAddonClient) Upgrade(ctx context.Context, currentSpec *cluster.Spec, newSpec *cluster.Spec) error {
	logger.V(1).Info("Checking for Flux upgrades")
	changeDiff := f.fluxChangeDiff(currentSpec, newSpec)
	if changeDiff == nil {
		logger.V(1).Info("Nothing to upgrade for Flux")
		return nil
	}

	logger.V(1).Info("Starting Flux upgrades")
	if err := f.upgradeFilesAndCommit(ctx, newSpec, changeDiff); err != nil {
		return fmt.Errorf("failed upgrading Flux from bundles %d to bundles %d: %v", currentSpec.Bundles.Spec.Number, newSpec.Bundles.Spec.Number, err)
	}

	return nil
}

func (f *FluxAddonClient) fluxChangeDiff(currentSpec, newSpec *cluster.Spec) *types.ComponentChangeDiff {
	if currentSpec.VersionsBundle.Flux.Version != newSpec.VersionsBundle.Flux.Version {
		changeDiff := &types.ComponentChangeDiff{
			ComponentName: "flux",
			NewVersion:    newSpec.VersionsBundle.ClusterAPI.Version,
			OldVersion:    currentSpec.VersionsBundle.ClusterAPI.Version,
		}
		logger.V(1).Info("Flux change diff", "oldVersion", changeDiff.OldVersion, "newVersion", changeDiff.NewVersion)
		return changeDiff
	}
	return nil
}

func (f *FluxAddonClient) upgradeFilesAndCommit(ctx context.Context, newSpec *cluster.Spec, changeDiff *types.ComponentChangeDiff) error {
	fc := &fluxForCluster{
		FluxAddonClient: f,
		clusterSpec:     newSpec,
	}

	if err := fc.commitFluxUpgradeFilesToGit(ctx); err != nil {
		return err
	}

	return nil
}

func (fc *fluxForCluster) commitFluxUpgradeFilesToGit(ctx context.Context) error {
	logger.Info("Adding flux configuration files to Git")
	config := fc.clusterSpec.GitOpsConfig
	repository := config.Spec.Flux.Github.Repository

	logger.V(3).Info("Generating flux custom manifest files...")
	err := fc.writeFluxUpgradeFiles()
	if err != nil {
		return err
	}

	p := path.Dir(config.Spec.Flux.Github.ClusterConfigPath)
	err = fc.gitOpts.Git.Add(p)
	if err != nil {
		return &ConfigVersionControlFailedError{Err: fmt.Errorf("error when adding %s to git: %v", p, err)}
	}

	err = fc.FluxAddonClient.pushToRemoteRepo(ctx, p, upgradeFluxconfigCommitMessage)
	if err != nil {
		return err
	}
	logger.V(3).Info("Finished pushing flux custom manifest files to git",
		"repository", repository)
	return nil
}

func (fc *fluxForCluster) writeFluxUpgradeFiles() error {
	w, err := fc.initFluxWriter()
	if err != nil {
		return err
	}

	t := templater.New(w)
	logger.V(3).Info("Generating flux-system patch file...")
	if err = fc.generateFluxPatchFile(t); err != nil {
		return err
	}

	return nil
}
